/*
 * Copyright 2022 interactive instruments GmbH
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package de.ii.xtraplatform.features.domain;

import de.ii.xtraplatform.base.domain.LogContext;
import de.ii.xtraplatform.features.domain.transform.PropertyTransformations;
import de.ii.xtraplatform.streams.domain.Reactive.Sink;
import de.ii.xtraplatform.streams.domain.Reactive.SinkReduced;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletionStage;
import javax.annotation.Nullable;
import javax.ws.rs.BadRequestException;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.EntityTag;
import org.immutables.value.Value;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public interface FeatureStream {

  Logger LOGGER = LoggerFactory.getLogger(FeatureStream.class);

  /**
   * Analyse the error reported by a feature stream. If it looks like a server-side error, re-throw
   * the exception, otherwise continue
   *
   * @param error the exception reported by xtraplatform
   */
  static void processStreamError(Throwable error) {
    String errorMessage = error.getMessage();
    if (Objects.isNull(errorMessage)) {
      errorMessage =
          error.getClass().getSimpleName() + " at " + error.getStackTrace()[0].toString();
    }
    Throwable rootError = error;
    while (Objects.nonNull(rootError) && !Objects.equals(rootError, rootError.getCause())) {
      if (rootError instanceof org.eclipse.jetty.io.EofException) {
        // the connection has been lost, typically the client has cancelled the request, log on
        // debug level
        LOGGER.debug("Request cancelled due to lost connection.");
        return;
      } else if (rootError instanceof WebApplicationException) {
        // Cannot handle request
        throw (WebApplicationException) rootError;
      } else if (rootError instanceof IllegalArgumentException) {
        // Bad request
        LogContext.errorAsDebug(LOGGER, rootError, "Invalid request");
        throw new BadRequestException(rootError.getMessage());
      } else if (rootError instanceof RuntimeException) {
        // Runtime exception is generated by XtraPlatform, look at the cause, if there is one
        if (Objects.nonNull(rootError.getCause())) {
          rootError = rootError.getCause();
        } else {
          // otherwise log the error
          break;
        }
      } else {
        // some other exception occurred, log as an error
        break;
      }
    }

    LogContext.error(LOGGER, rootError, "");

    throw new InternalServerErrorException(errorMessage, error);
  }

  @Value.Immutable
  interface Result extends ResultBase {

    abstract class Builder extends ResultBase.Builder<Result, Builder> {}

    Optional<EntityTag> getETag();
  }

  @Value.Immutable
  interface ResultReduced<T> extends ResultBase {

    abstract class Builder<T> extends ResultBase.Builder<ResultReduced<T>, Builder<T>> {

      public abstract Builder<T> reduced(T bytes);
    }

    @Nullable
    T reduced();

    Optional<EntityTag> getETag();
  }

  interface ResultBase {

    abstract class Builder<T extends ResultBase, U extends Builder<T, U>> {

      public abstract U isEmpty(boolean isEmpty);

      public abstract U hasFeatures(boolean hasFeatures);

      public abstract U error(Throwable error);

      public abstract T build();
    }

    @Value.Derived
    default boolean isSuccess() {
      return getError().isEmpty();
    }

    boolean isEmpty();

    boolean hasFeatures();

    Optional<Throwable> getError();
  }

  CompletionStage<Result> runWith(
      Sink<Object> sink, Map<String, PropertyTransformations> propertyTransformations);

  <X> CompletionStage<ResultReduced<X>> runWith(
      SinkReduced<Object, X> sink, Map<String, PropertyTransformations> propertyTransformations);

  // CompletionStage<Result> runWith(SinkTransformed<Object, byte[]> sink,
  // Optional<PropertyTransformations> propertyTransformations);

  // CompletionStage<ResultReduced<byte[]>> runWith(SinkReducedTransformed<Object, byte[], byte[]>
  // sink, Optional<PropertyTransformations> propertyTransformations);
}
