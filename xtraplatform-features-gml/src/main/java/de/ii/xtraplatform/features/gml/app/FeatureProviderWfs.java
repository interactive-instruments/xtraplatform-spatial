/*
 * Copyright 2022 interactive instruments GmbH
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package de.ii.xtraplatform.features.gml.app;

import com.google.common.collect.ImmutableList;
import dagger.assisted.Assisted;
import dagger.assisted.AssistedInject;
import de.ii.xtraplatform.base.domain.resiliency.VolatileRegistry;
import de.ii.xtraplatform.codelists.domain.Codelist;
import de.ii.xtraplatform.cql.domain.Cql;
import de.ii.xtraplatform.crs.domain.BoundingBox;
import de.ii.xtraplatform.crs.domain.CrsInfo;
import de.ii.xtraplatform.crs.domain.CrsTransformationException;
import de.ii.xtraplatform.crs.domain.CrsTransformerFactory;
import de.ii.xtraplatform.crs.domain.EpsgCrs;
import de.ii.xtraplatform.crs.domain.OgcCrs;
import de.ii.xtraplatform.docs.DocDefs;
import de.ii.xtraplatform.docs.DocStep;
import de.ii.xtraplatform.docs.DocStep.Step;
import de.ii.xtraplatform.docs.DocTable;
import de.ii.xtraplatform.docs.DocTable.ColumnSet;
import de.ii.xtraplatform.entities.domain.Entity;
import de.ii.xtraplatform.entities.domain.Entity.SubType;
import de.ii.xtraplatform.features.domain.AbstractFeatureProvider;
import de.ii.xtraplatform.features.domain.AggregateStatsReader;
import de.ii.xtraplatform.features.domain.ConnectorFactory;
import de.ii.xtraplatform.features.domain.FeatureCrs;
import de.ii.xtraplatform.features.domain.FeatureEventHandler.ModifiableContext;
import de.ii.xtraplatform.features.domain.FeatureExtents;
import de.ii.xtraplatform.features.domain.FeatureMetadata;
import de.ii.xtraplatform.features.domain.FeatureProvider;
import de.ii.xtraplatform.features.domain.FeatureProviderConnector;
import de.ii.xtraplatform.features.domain.FeatureProviderConnector.QueryOptions;
import de.ii.xtraplatform.features.domain.FeatureProviderDataV2;
import de.ii.xtraplatform.features.domain.FeatureQueries;
import de.ii.xtraplatform.features.domain.FeatureQueriesPassThrough;
import de.ii.xtraplatform.features.domain.FeatureQuery;
import de.ii.xtraplatform.features.domain.FeatureQueryEncoder;
import de.ii.xtraplatform.features.domain.FeatureSchema;
import de.ii.xtraplatform.features.domain.FeatureStorePathParser;
import de.ii.xtraplatform.features.domain.FeatureStream;
import de.ii.xtraplatform.features.domain.FeatureStreamImpl;
import de.ii.xtraplatform.features.domain.FeatureTokenDecoder;
import de.ii.xtraplatform.features.domain.Metadata;
import de.ii.xtraplatform.features.domain.ProviderData;
import de.ii.xtraplatform.features.domain.ProviderExtensionRegistry;
import de.ii.xtraplatform.features.domain.Query;
import de.ii.xtraplatform.features.domain.SchemaMapping;
import de.ii.xtraplatform.features.domain.transform.OnlyQueryables;
import de.ii.xtraplatform.features.domain.transform.OnlySortables;
import de.ii.xtraplatform.features.gml.domain.ConnectionInfoWfsHttp;
import de.ii.xtraplatform.features.gml.domain.FeatureProviderWfsData;
import de.ii.xtraplatform.features.gml.domain.WfsConnector;
import de.ii.xtraplatform.features.gml.domain.XMLNamespaceNormalizer;
import de.ii.xtraplatform.streams.domain.Reactive;
import de.ii.xtraplatform.streams.domain.Reactive.Stream;
import de.ii.xtraplatform.values.domain.ValueStore;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.ws.rs.core.MediaType;
import javax.xml.namespace.QName;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.threeten.extra.Interval;

/**
 * @title WFS
 * @sortPriority 50
 * @langEn The features are retrieved from an OGC WFS.
 * @langDe Die Features werden von einem OGC WFS bezogen.
 * @cfgPropertiesAdditionalEn ### Connection Info
 *     <p>The connection info object for OGC Web Feature Services has the following properties:
 *     <p>{@docTable:connectionInfo}
 *     <p>### Path Syntax
 *     <p>The paths for WFS feature providers are generated by ldproxy when analyzing the WFS und
 *     should not be changed.
 * @cfgPropertiesAdditionalDe ### Connection Info
 *     <p>Das Connection-Info-Objekt für OGC Web Feature Services wird wie folgt beschrieben:
 *     <p>{@docTable:connectionInfo}
 *     <p>### Pfad-Syntax
 *     <p>Die Pfade in den WFS-Feature-Providern werden von ldproxy bei der Analyse des WFS gebildet
 *     und sollten nicht verändert werden.
 * @ref:connectionInfo {@link de.ii.xtraplatform.features.gml.domain.ImmutableConnectionInfoWfsHttp}
 * @ref:cfg {@link de.ii.xtraplatform.features.gml.domain.ConnectionInfoWfsHttp}
 */
@DocDefs(
    tables = {
      @DocTable(
          name = "connectionInfo",
          rows = {
            @DocStep(type = Step.TAG_REFS, params = "{@ref:connectionInfo}"),
            @DocStep(type = Step.JSON_PROPERTIES)
          },
          columnSet = ColumnSet.JSON_PROPERTIES),
    })
@Entity(
    type = ProviderData.ENTITY_TYPE,
    subTypes = {
      @SubType(key = ProviderData.PROVIDER_TYPE_KEY, value = FeatureProvider.PROVIDER_TYPE),
      @SubType(
          key = ProviderData.PROVIDER_SUB_TYPE_KEY,
          value = FeatureProviderWfs.PROVIDER_SUB_TYPE)
    },
    data = FeatureProviderWfsData.class)
public class FeatureProviderWfs
    extends AbstractFeatureProvider<
        byte[], String, FeatureProviderConnector.QueryOptions, FeatureSchema>
    implements FeatureProvider,
        FeatureQueries,
        FeatureCrs,
        FeatureExtents,
        FeatureMetadata,
        FeatureQueriesPassThrough {

  private static final Logger LOGGER = LoggerFactory.getLogger(FeatureProviderWfs.class);

  static final String ENTITY_SUB_TYPE = "feature/wfs";
  public static final String PROVIDER_SUB_TYPE = "WFS";
  private static final MediaType MEDIA_TYPE = new MediaType("application", "gml+xml");

  private final CrsTransformerFactory crsTransformerFactory;
  private final Cql cql;

  private FeatureQueryEncoderWfs queryTransformer;
  private AggregateStatsReader<FeatureSchema> aggregateStatsReader;
  private FeatureStorePathParser pathParser;

  @AssistedInject
  public FeatureProviderWfs(
      CrsTransformerFactory crsTransformerFactory,
      Cql cql,
      ConnectorFactory connectorFactory,
      Reactive reactive,
      ValueStore valueStore,
      ProviderExtensionRegistry extensionRegistry,
      VolatileRegistry volatileRegistry,
      @Assisted FeatureProviderDataV2 data) {
    super(
        connectorFactory,
        reactive,
        crsTransformerFactory,
        extensionRegistry,
        valueStore.forType(Codelist.class),
        data,
        volatileRegistry);

    this.crsTransformerFactory = crsTransformerFactory;
    this.cql = cql;
  }

  @Override
  protected boolean onStartup() throws InterruptedException {
    this.pathParser = createPathParser(getData().getConnectionInfo());

    boolean success = super.onStartup();

    if (!success) {
      return false;
    }

    this.queryTransformer =
        new FeatureQueryEncoderWfs(
            getData().getTypes(),
            getData().getConnectionInfo(),
            getData().getNativeCrs().orElse(OgcCrs.CRS84),
            crsTransformerFactory,
            cql);
    this.aggregateStatsReader =
        new AggregateStatsReaderWfs(
            this, crsTransformerFactory, getData().getNativeCrs().orElse(OgcCrs.CRS84));

    return true;
  }

  @Override
  protected Map<String, List<FeatureSchema>> getSourceSchemas() {
    Map<String, List<FeatureSchema>> types =
        getData().getTypes().entrySet().stream()
            .map(entry -> new SimpleImmutableEntry<>(entry.getKey(), List.of(entry.getValue())))
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    return types;
  }

  private static FeatureStorePathParser createPathParser(
      ConnectionInfoWfsHttp connectionInfoWfsHttp) {
    return new FeatureStorePathParserWfs(connectionInfoWfsHttp.getNamespaces());
  }

  @Override
  public FeatureProviderWfsData getData() {
    return (FeatureProviderWfsData) super.getData();
  }

  @Override
  protected WfsConnector getConnector() {
    return (WfsConnector) super.getConnector();
  }

  @Override
  protected FeatureQueryEncoder<String, QueryOptions> getQueryEncoder() {
    return queryTransformer;
  }

  @Override
  protected FeatureTokenDecoder<
          byte[], FeatureSchema, SchemaMapping, ModifiableContext<FeatureSchema, SchemaMapping>>
      getDecoder(Query query, Map<String, SchemaMapping> mappings) {
    return getDecoder(query, mappings, false);
  }

  @Override
  protected FeatureTokenDecoder<
          byte[], FeatureSchema, SchemaMapping, ModifiableContext<FeatureSchema, SchemaMapping>>
      getDecoderPassThrough(Query query) {
    return getDecoder(query, Map.of(), true);
  }

  private FeatureTokenDecoder<
          byte[], FeatureSchema, SchemaMapping, ModifiableContext<FeatureSchema, SchemaMapping>>
      getDecoder(Query query, Map<String, SchemaMapping> mappings, boolean passThrough) {
    if (!(query instanceof FeatureQuery)) {
      throw new IllegalArgumentException();
    }
    FeatureQuery featureQuery = (FeatureQuery) query;
    Map<String, String> namespaces = getData().getConnectionInfo().getNamespaces();
    XMLNamespaceNormalizer namespaceNormalizer = new XMLNamespaceNormalizer(namespaces);
    FeatureSchema featureSchema = getData().getTypes().get(featureQuery.getType());
    String name =
        featureSchema.getSourcePath().map(sourcePath -> sourcePath.substring(1)).orElse(null);
    QName qualifiedName =
        new QName(
            namespaceNormalizer.getNamespaceURI(namespaceNormalizer.extractURI(name)),
            namespaceNormalizer.getLocalName(name));
    return new FeatureTokenDecoderGml(
        namespaces,
        ImmutableList.of(qualifiedName),
        featureSchema,
        featureQuery,
        mappings,
        passThrough);
  }

  @Override
  public EpsgCrs getNativeCrs() {
    return getData().getNativeCrs().get();
  }

  @Override
  public boolean isCrsSupported(EpsgCrs crs) {
    return Objects.equals(getNativeCrs(), crs) || crsTransformerFactory.isSupported(crs);
  }

  @Override
  public boolean is3dSupported() {
    return ((CrsInfo) crsTransformerFactory).is3d(getNativeCrs());
  }

  @Override
  public long getFeatureCount(String typeName) {
    if (getData().getTypes().containsKey(typeName)) {
      return -1;
    }

    try {
      Stream<Long> countGraph =
          aggregateStatsReader.getCount(List.of(getData().getTypes().get(typeName)));

      return countGraph
          .on(getStreamRunner())
          .run()
          .exceptionally(throwable -> -1L)
          .toCompletableFuture()
          .join();
    } catch (Throwable e) {
      // continue
    }

    return -1;
  }

  @Override
  public FeatureSchema getQueryablesSchema(
      FeatureSchema schema,
      List<String> included,
      List<String> excluded,
      String pathSeparator,
      boolean cleanupKeys) {
    OnlyQueryables queryablesSelector =
        new OnlyQueryables(included, excluded, pathSeparator, (path) -> false, cleanupKeys);

    return schema.accept(queryablesSelector);
  }

  @Override
  public FeatureSchema getSortablesSchema(
      FeatureSchema schema, List<String> included, List<String> excluded, String pathSeparator) {
    OnlySortables sortablesSelector =
        new OnlySortables(included, excluded, pathSeparator, (path) -> false);

    return schema.accept(sortablesSelector);
  }

  @Override
  public Optional<BoundingBox> getSpatialExtent(String typeName) {
    if (getData().getTypes().containsKey(typeName)) {
      return Optional.empty();
    }

    try {
      Stream<Optional<BoundingBox>> extentGraph =
          aggregateStatsReader.getSpatialExtent(
              List.of(getData().getTypes().get(typeName)), is3dSupported());

      return extentGraph
          .on(getStreamRunner())
          .run()
          .exceptionally(throwable -> Optional.empty())
          .toCompletableFuture()
          .join();
    } catch (Throwable e) {
      // continue
      boolean br = true;
    }

    return Optional.empty();
  }

  @Override
  public Optional<BoundingBox> getSpatialExtent(String typeName, EpsgCrs crs) {
    return getSpatialExtent(typeName)
        .flatMap(
            boundingBox ->
                crsTransformerFactory
                    .getTransformer(getNativeCrs(), crs, false)
                    .flatMap(
                        crsTransformer -> {
                          try {
                            return Optional.of(crsTransformer.transformBoundingBox(boundingBox));
                          } catch (CrsTransformationException e) {
                            return Optional.empty();
                          }
                        }));
  }

  @Override
  public Optional<Interval> getTemporalExtent(String typeName) {
    return Optional.empty();
  }

  @Override
  public Optional<Metadata> getMetadata() {
    return getConnector().getMetadata();
  }

  @Override
  public MediaType getMediaType() {
    return MEDIA_TYPE;
  }

  @Override
  public FeatureStream getFeatureStreamPassThrough(FeatureQuery query) {
    return new FeatureStreamImpl(
        query, getData(), crsTransformerFactory, getCodelists(), this::runQuery, false);
  }
}
